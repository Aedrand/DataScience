if(p<0.01) txt2 <- paste("p= ", "<0.01", sep = "")
text(0.5, 0.4, txt2)
}
#REPORTING
#Setup the data, loading from an Rda file.
#Storing in seperate frame because I'm not entirely sure how R works and don't want to overwrite the original data.
load('steamspy.Rda')
gamedata <- steamspy
#MODIFICATIONS
#Convert tag columns to either 1 or 0, based on whether or not the game can be categorized by that tag.
#Allows for an easier time categorizing by tags, and improves the overall readability of the data.
tagrows <- gamedata[,18:ncol(gamedata)]
tagrows[!is.na(tagrows)] <- 1
tagrows[is.na(tagrows)] <- 0
gamedata[,18:347] <- tagrows
rm(tagrows)
free <- gamedata[gamedata[,18] == 1,]
mean(free$average_forever)
mean(gamedata[gamedata[,18] == 1,]$average_forever)
#Replace all commas in the name, developer, and publisher columns to allow proper writing to csv.
gamedata$name <- gsub(","," &",gamedata$name)
gamedata$developer <- gsub(","," &",gamedata$developer)
gamedata$publisher <- gsub(","," &",gamedata$publisher)
#Remove rows where the price is NA, as these end up being unpublished or packaged software.
gamedata <- gamedata[!is.na(gamedata$price),]
#Remove the appid and name columns from the data, as they are largely irrelevant
gamedata$appid <- NULL
gamedata$name <- NULL
View(gamedata)
load('modgamedata.Rda')
load('modgamedata100.Rda')
load('modgamedata1000.Rda')
moddata <- gamedata
moddata100 <- gamedata100
moddata1000 <- gamedata1000
rm(gamedata)
rm(gamedata100)
rm(gamedata1000)
#SETUP
#Define a function to calculate Pearson's r for inclusion in a scatter plot matrix- from Lab4.R
panel.cor <- function(x, y, digits = 2, cex.cor, ...)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
# correlation coefficient
r <- cor(x, y)
txt <- format(c(r, 0.123456789), digits = digits)[1]
txt <- paste("r= ", txt, sep = "")
text(0.5, 0.6, txt)
# p-value calculation
p <- cor.test(x, y)$p.value
txt2 <- format(c(p, 0.123456789), digits = digits)[1]
txt2 <- paste("p= ", txt2, sep = "")
if(p<0.01) txt2 <- paste("p= ", "<0.01", sep = "")
text(0.5, 0.4, txt2)
}
#Convert price and score columns from chr to int.
gamedata$price <- as.numeric(gamedata$price)
gamedata$score_rank <- as.numeric(gamedata$score_rank)
#Create two other versions of the data, removing any entries below 100 average minutes and 1000 average minutes, respectively.
gamedata100 <- gamedata[gamedata$average_forever >= 100,]
gamedata1000 <- gamedata[gamedata$average_forever >= 1000,]
#WRITING
#Write the data to an Rda file and a csv file
save(gamedata, file= 'modgamedata.Rda')
save(gamedata100, file= 'modgamedata100.Rda')
save(gamedata1000, file= 'modgamedata1000.Rda')
gamedata <- as.matrix(gamedata)
write.csv(gamedata, file= 'modGameData.csv')
rm(gamedata)
#LOADING
#Setup the data, loading from an Rda file.
#Storing in seperate frame because I'm not entirely sure how R works and don't want to overwrite the original data.
load('steamspy.Rda')
gamedata <- steamspy
#MODIFICATIONS
#Convert tag columns to either 1 or 0, based on whether or not the game can be categorized by that tag.
#Allows for an easier time categorizing by tags, and improves the overall readability of the data.
tagrows <- gamedata[,18:ncol(gamedata)]
tagrows[!is.na(tagrows)] <- 1
tagrows[is.na(tagrows)] <- 0
gamedata[,18:347] <- tagrows
rm(tagrows)
free <- gamedata[gamedata[,18] == 1,]
mean(free$average_forever)
mean(gamedata[gamedata[,18] == 1,]$average_forever)
#Replace all commas in the name, developer, and publisher columns to allow proper writing to csv.
gamedata$name <- gsub(","," &",gamedata$name)
gamedata$developer <- gsub(","," &",gamedata$developer)
gamedata$publisher <- gsub(","," &",gamedata$publisher)
#Remove rows where the price is NA, as these end up being unpublished or packaged software.
gamedata <- gamedata[!is.na(gamedata$price),]
#Remove the appid and name columns from the data, as they are largely irrelevant
gamedata$appid <- NULL
gamedata$name <- NULL
#Convert price and score columns from chr to int.
gamedata$price <- as.numeric(gamedata$price)
gamedata$score_rank <- as.numeric(gamedata$score_rank)
#Create two other versions of the data, removing any entries below 100 average minutes and 1000 average minutes, respectively.
gamedata100 <- gamedata[gamedata$average_forever >= 100,]
gamedata1000 <- gamedata[gamedata$average_forever >= 1000,]
#WRITING
#Write the data to an Rda file and a csv file
save(gamedata, file= 'modgamedata.Rda')
save(gamedata100, file= 'modgamedata100.Rda')
save(gamedata1000, file= 'modgamedata1000.Rda')
gamedata <- as.matrix(gamedata)
write.csv(gamedata, file= 'modGameData.csv')
rm(gamedata)
#Load the data from an Rda file.
#All data modification should be done prior to running this script.
#Storing in seperate frame because I'm not entirely sure how R works and don't want to overwrite the original data
load('modgamedata.Rda')
load('modgamedata100.Rda')
load('modgamedata1000.Rda')
moddata <- gamedata
moddata100 <- gamedata100
moddata1000 <- gamedata1000
rm(gamedata)
rm(gamedata100)
rm(gamedata1000)
corModdata <- cor(moddata[,3:ncol(moddata)])
corModdata <- cor(moddata[,3:10])
corrplot(corModdata, main = "Correlation Plot")
corModdata <- cor(moddata[,3:14])
corrplot(corModdata, main = "Correlation Plot")
for(i in 3:20)
corModdata <- cor(moddata[,3:20])
corrplot(corModdata, main = "Correlation Plot")
corModdata <- cor(moddata[,3:200])
corrplot(corModdata, main = "Correlation Plot")
corModdata <- cor(moddata[,3:40])
corrplot(corModdata, main = "Correlation Plot")
corModdata <- cor(moddata[,3:10])
corrplot(corModdata, main = "Correlation Plot")
corModdata <- cor(moddata[,2:10])
corrplot(corModdata, main = "Correlation Plot")
corModdata <- cor(moddata[,3:15])
corrplot(corModdata, main = "Correlation Plot")
load('steamspy.Rda')
gamedata <- steamspy
#MODIFICATIONS
#Convert tag columns to either 1 or 0, based on whether or not the game can be categorized by that tag.
#Allows for an easier time categorizing by tags, and improves the overall readability of the data.
tagrows <- gamedata[,18:ncol(gamedata)]
tagrows[!is.na(tagrows)] <- 1
tagrows[is.na(tagrows)] <- 0
gamedata[,18:347] <- tagrows
rm(tagrows)
free <- gamedata[gamedata[,18] == 1,]
mean(free$average_forever)
mean(gamedata[gamedata[,18] == 1,]$average_forever)
#Remove features that are too highly correlated with each other, and are largely irrelevant
View(gamedata)
gamedata$appid <- NULL
gamedata$name <- NULL
gamedata[,4:9] <- NULL
gamedata[,5:8] <- NULL
load('steamspy.Rda')
gamedata <- steamspy
#MODIFICATIONS
#Convert tag columns to either 1 or 0, based on whether or not the game can be categorized by that tag.
#Allows for an easier time categorizing by tags, and improves the overall readability of the data.
tagrows <- gamedata[,18:ncol(gamedata)]
tagrows[!is.na(tagrows)] <- 1
tagrows[is.na(tagrows)] <- 0
gamedata[,18:347] <- tagrows
rm(tagrows)
free <- gamedata[gamedata[,18] == 1,]
mean(free$average_forever)
mean(gamedata[gamedata[,18] == 1,]$average_forever)
#Remove features that are too highly correlated with each other, and are largely irrelevant
gamedata$appid <- NULL
gamedata$name <- NULL
gamedata[,4:9] <- NULL
gamedata[,5:8] <- NULL
gamedata$developer <- gsub(","," &",gamedata$developer)
gamedata$publisher <- gsub(","," &",gamedata$publisher)
#Remove rows where the price is NA, as these end up being unpublished or packaged software.
gamedata <- gamedata[!is.na(gamedata$price),]
#Convert price and score columns from chr to int.
gamedata$price <- as.numeric(gamedata$price)
gamedata$score_rank <- as.numeric(gamedata$score_rank)
#Create two other versions of the data, removing any entries below 100 average minutes and 1000 average minutes, respectively.
gamedata100 <- gamedata[gamedata$average_forever >= 100,]
gamedata1000 <- gamedata[gamedata$average_forever >= 1000,]
#WRITING
#Write the data to an Rda file and a csv file
save(gamedata, file= 'modgamedata.Rda')
save(gamedata100, file= 'modgamedata100.Rda')
save(gamedata1000, file= 'modgamedata1000.Rda')
gamedata <- as.matrix(gamedata)
write.csv(gamedata, file= 'modGameData.csv')
rm(gamedata)
load('modgamedata.Rda')
load('modgamedata100.Rda')
load('modgamedata1000.Rda')
moddata <- gamedata
moddata100 <- gamedata100
moddata1000 <- gamedata1000
rm(gamedata)
rm(gamedata100)
rm(gamedata1000)
for(i in 6:ncol(moddata))
{
writeLines(paste("Number of items tagged with",colnames(moddata)[i],sep = " "))
print(nrow(moddata[moddata[,i] == 1,]))
}
load('steamspy.Rda')
gamedata <- steamspy
#MODIFICATIONS
#Convert tag columns to either 1 or 0, based on whether or not the game can be categorized by that tag.
#Allows for an easier time categorizing by tags, and improves the overall readability of the data.
tagrows <- gamedata[,18:ncol(gamedata)]
tagrows[!is.na(tagrows)] <- 1
tagrows[is.na(tagrows)] <- 0
gamedata[,18:347] <- tagrows
rm(tagrows)
free <- gamedata[gamedata[,18] == 1,]
mean(free$average_forever)
mean(gamedata[gamedata[,18] == 1,]$average_forever)
#Remove features that are too highly correlated with each other, and are largely irrelevant
gamedata$appid <- NULL
gamedata$name <- NULL
gamedata[,4:9] <- NULL
gamedata[,5:8] <- NULL
#Replace all commas in the developer and publisher columns to allow proper writing to csv.
gamedata$developer <- gsub(","," &",gamedata$developer)
gamedata$publisher <- gsub(","," &",gamedata$publisher)
#Remove rows where the price is NA, as these end up being unpublished or packaged software.
gamedata <- gamedata[!is.na(gamedata$price),]
#Convert price and score columns from chr to int.
gamedata$price <- as.numeric(gamedata$price)
gamedata$score_rank <- as.numeric(gamedata$score_rank)
#Create two other versions of the data, removing any entries below 100 average minutes and 1000 average minutes, respectively.
gamedata100 <- gamedata[gamedata$average_forever >= 100,]
gamedata1000 <- gamedata[gamedata$average_forever >= 1000,]
#Remove tag features whose counts are lower than
for(i in 6:ncol(gamedata)) {
if(nrow(gamedata[gamedata[,i] == 1,]) < 6) {
gamedata[,i] <- NULL
}
}
load('steamspy.Rda')
gamedata <- steamspy
#MODIFICATIONS
#Convert tag columns to either 1 or 0, based on whether or not the game can be categorized by that tag.
#Allows for an easier time categorizing by tags, and improves the overall readability of the data.
tagrows <- gamedata[,18:ncol(gamedata)]
tagrows[!is.na(tagrows)] <- 1
tagrows[is.na(tagrows)] <- 0
gamedata[,18:347] <- tagrows
rm(tagrows)
free <- gamedata[gamedata[,18] == 1,]
mean(free$average_forever)
mean(gamedata[gamedata[,18] == 1,]$average_forever)
#Remove features that are too highly correlated with each other, and are largely irrelevant
gamedata$appid <- NULL
gamedata$name <- NULL
gamedata[,4:9] <- NULL
gamedata[,5:8] <- NULL
#Replace all commas in the developer and publisher columns to allow proper writing to csv.
gamedata$developer <- gsub(","," &",gamedata$developer)
gamedata$publisher <- gsub(","," &",gamedata$publisher)
#Remove rows where the price is NA, as these end up being unpublished or packaged software.
gamedata <- gamedata[!is.na(gamedata$price),]
#Convert price and score columns from chr to int.
gamedata$price <- as.numeric(gamedata$price)
gamedata$score_rank <- as.numeric(gamedata$score_rank)
for(i in 6:ncol(gamedata)) {
if(nrow(gamedata[gamedata[,i] == 1,]) < 10) {
gamedata[,i] <- NA
}
}
for(i in 6:ncol(gamedata)) {
if(nrow(gamedata[gamedata[,i] == 1,]) < 20) {
gamedata[,i] <- NA
}
}
gamedata$Gaming[1]
x[sapply(x, function(x) !any(is.na(x)))]
gamedata[sapply(gamedata, function(gamedata) !any(is.na(gamedata)))]
gamedata[, colSums(is.na(df)) != nrow(df)]
gamedata[, colSums(is.na(gamedata)) != nrow(gamedata)]
gamedata <- gamedata[, colSums(is.na(gamedata)) != nrow(gamedata)]
View(gamedata)
for(i in 6:ncol(moddata))
{
writeLines(paste("Number of items tagged with",colnames(moddata)[i],sep = " "))
print(nrow(moddata[moddata[,i] == 1,]))
}
load('modgamedata.Rda')
load('modgamedata100.Rda')
load('modgamedata1000.Rda')
moddata <- gamedata
moddata100 <- gamedata100
moddata1000 <- gamedata1000
rm(gamedata)
rm(gamedata100)
rm(gamedata1000)
for(i in 6:ncol(moddata))
{
writeLines(paste("Number of items tagged with",colnames(moddata)[i],sep = " "))
print(nrow(moddata[moddata[,i] == 1,]))
}
#Andrew Riggs
#Data modification procedures for CS376B
#LOADING
#Setup the data, loading from an Rda file.
#Storing in seperate frame because I'm not entirely sure how R works and don't want to overwrite the original data.
load('steamspy.Rda')
gamedata <- steamspy
#MODIFICATIONS
#Convert tag columns to either 1 or 0, based on whether or not the game can be categorized by that tag.
#Allows for an easier time categorizing by tags, and improves the overall readability of the data.
tagrows <- gamedata[,18:ncol(gamedata)]
tagrows[!is.na(tagrows)] <- 1
tagrows[is.na(tagrows)] <- 0
gamedata[,18:347] <- tagrows
rm(tagrows)
free <- gamedata[gamedata[,18] == 1,]
mean(free$average_forever)
mean(gamedata[gamedata[,18] == 1,]$average_forever)
#Remove features that are too highly correlated with each other, and are largely irrelevant
gamedata$appid <- NULL
gamedata$name <- NULL
gamedata[,4:9] <- NULL
gamedata[,5:8] <- NULL
#Replace all commas in the developer and publisher columns to allow proper writing to csv.
gamedata$developer <- gsub(","," &",gamedata$developer)
gamedata$publisher <- gsub(","," &",gamedata$publisher)
#Remove rows where the price is NA, as these end up being unpublished or packaged software.
gamedata <- gamedata[!is.na(gamedata$price),]
#Convert price and score columns from chr to int.
gamedata$price <- as.numeric(gamedata$price)
gamedata$score_rank <- as.numeric(gamedata$score_rank)
#Remove tag features whose counts are lower than 20
for(i in 6:ncol(gamedata)) {
if(nrow(gamedata[gamedata[,i] == 1,]) < 20) {
gamedata[,i] <- NA
}
}
gamedata <- gamedata[, colSums(is.na(gamedata)) != nrow(gamedata)]
#Create two other versions of the data, removing any entries below 100 average minutes and 1000 average minutes, respectively.
gamedata100 <- gamedata[gamedata$average_forever >= 100,]
gamedata1000 <- gamedata[gamedata$average_forever >= 1000,]
#WRITING
#Write the data to an Rda file and a csv file
save(gamedata, file= 'modgamedata.Rda')
save(gamedata100, file= 'modgamedata100.Rda')
save(gamedata1000, file= 'modgamedata1000.Rda')
gamedata <- as.matrix(gamedata)
write.csv(gamedata, file= 'modGameData.csv')
rm(gamedata)
#Andrew Riggs
#Data quality report script for CS376B
#LOADING
#Load the necessary libraries.
library(corrplot)
library(aplpack)
library(modes)
library(googleVis)
#Load the data from an Rda file.
#All data modification should be done prior to running this script.
#Storing in seperate frame because I'm not entirely sure how R works and don't want to overwrite the original data
load('modgamedata.Rda')
load('modgamedata100.Rda')
load('modgamedata1000.Rda')
moddata <- gamedata
moddata100 <- gamedata100
moddata1000 <- gamedata1000
rm(gamedata)
rm(gamedata100)
rm(gamedata1000)
for(i in 6:ncol(moddata))
{
writeLines(paste("Number of items tagged with",colnames(moddata)[i],sep = " "))
print(nrow(moddata[moddata[,i] == 1,]))
}
#LOADING
#Setup the data, loading from an Rda file.
#Storing in seperate frame because I'm not entirely sure how R works and don't want to overwrite the original data.
load('steamspy.Rda')
gamedata <- steamspy
#MODIFICATIONS
#Convert tag columns to either 1 or 0, based on whether or not the game can be categorized by that tag.
#Allows for an easier time categorizing by tags, and improves the overall readability of the data.
tagrows <- gamedata[,18:ncol(gamedata)]
tagrows[!is.na(tagrows)] <- 1
tagrows[is.na(tagrows)] <- 0
gamedata[,18:347] <- tagrows
rm(tagrows)
free <- gamedata[gamedata[,18] == 1,]
mean(free$average_forever)
mean(gamedata[gamedata[,18] == 1,]$average_forever)
#Remove features that are too highly correlated with each other, and are largely irrelevant
gamedata$appid <- NULL
gamedata$name <- NULL
gamedata[,4:9] <- NULL
gamedata[,5:8] <- NULL
#Replace all commas in the developer and publisher columns to allow proper writing to csv.
gamedata$developer <- gsub(","," &",gamedata$developer)
gamedata$publisher <- gsub(","," &",gamedata$publisher)
#Remove rows where the price is NA, as these end up being unpublished or packaged software.
gamedata <- gamedata[!is.na(gamedata$price),]
#Convert price and score columns from chr to int.
gamedata$price <- as.numeric(gamedata$price)
gamedata$score_rank <- as.numeric(gamedata$score_rank)
#Remove tag features whose counts are lower than 20
for(i in 6:ncol(gamedata)) {
if(nrow(gamedata[gamedata[,i] == 1,]) < 20) {
gamedata[,i] <- NA
}
}
gamedata <- gamedata[, colSums(is.na(gamedata)) != nrow(gamedata)]
#Create two other versions of the data, removing any entries below 100 average minutes and 1000 average minutes, respectively.
gamedata100 <- gamedata[gamedata$average_forever >= 100,]
gamedata1000 <- gamedata[gamedata$average_forever >= 1000,]
View(gamedata)
colSums(gamedata[1,])
colSums(gamedata[1,6:ncol(gamedata)])
colSums(gamedata[1,6:287])
colSums(gamedata[1,6:20])
rowSums(gamedata[1,6:20])
rowSums(gamedata[1,6:100])
rowSums(gamedata[1,6:200])
save(gamedata, file= 'modgamedata.Rda')
gamedata <- as.matrix(gamedata)
write.csv(gamedata, file= 'modGameData.csv')
load('steamspy.Rda')
gamedata <- steamspy
#MODIFICATIONS
#Convert tag columns to either 1 or 0, based on whether or not the game can be categorized by that tag.
#Allows for an easier time categorizing by tags, and improves the overall readability of the data.
tagrows <- gamedata[,18:ncol(gamedata)]
tagrows[!is.na(tagrows)] <- 1
tagrows[is.na(tagrows)] <- 0
gamedata[,18:347] <- tagrows
rm(tagrows)
free <- gamedata[gamedata[,18] == 1,]
mean(free$average_forever)
mean(gamedata[gamedata[,18] == 1,]$average_forever)
#Remove features that are too highly correlated with each other, and are largely irrelevant
gamedata$appid <- NULL
gamedata$name <- NULL
gamedata[,4:9] <- NULL
gamedata[,5:8] <- NULL
#Replace all commas in the developer and publisher columns to allow proper writing to csv.
gamedata$developer <- gsub(","," &",gamedata$developer)
gamedata$publisher <- gsub(","," &",gamedata$publisher)
#Remove rows where the price is NA, as these end up being unpublished or packaged software.
gamedata <- gamedata[!is.na(gamedata$price),]
#Convert price and score columns from chr to int.
gamedata$price <- as.numeric(gamedata$price)
gamedata$score_rank <- as.numeric(gamedata$score_rank)
#Remove tag features whose counts are lower than 20
for(i in 6:ncol(gamedata)) {
if(nrow(gamedata[gamedata[,i] == 1,]) < 20) {
gamedata[,i] <- NA
}
}
gamedata <- gamedata[, colSums(is.na(gamedata)) != nrow(gamedata)]
str(gamedata$`6DOF`)
nrow(gamedata[gamedata$`6DOF` == 1])
nrow(gamedata[,gamedata$`6DOF` == 1])
rowSums(gamedata[1,6:200])
rowSums(gamedata[1,6:150])
rowSums(gamedata[1,6:160])
rowSums(gamedata[1,6:170])
rowSums(gamedata[1,6:180])
rowSums(gamedata[1,6:190])
gamedatahelp <- gamedata[,18-:190]
gamedatahelp <- gamedata[,18:190]
View(gamedatahelp)
rowSums(gamedata[1,6:190])
rowSums(gamedata[1,180:190])
gamedatahelp <- gamedata[,180:190]
View(gamedatahelp)
gamedata$tags <- NULL
rowSums(gamedata[1,6:ncol(gamedata)])
rm(gamedatahelp)
for(i in 1:nrow(gamedata)) {
if(rowSums(gamedata[i,]) < 1) {
gamedata[i,] <- NA
}
}
for(i in 1:nrow(gamedata)) {
if(rowSums(gamedata[i,]) < 1) {
gamedata[i,6:ncol(gamedata)] <- NA
}
}
for(i in 1:nrow(gamedata)) {
if(rowSums(gamedata[i,6:ncol]) < 1) {
gamedata[i,] <- NA
}
}
for(i in 1:nrow(gamedata)) {
if(rowSums(gamedata[i,6:ncol(gamedata)]) < 1) {
gamedata[i,] <- NA
}
}
here <- gamedata[is.na(gamedata$`Free to Play`)
here <- gamedata[is.na(gamedata$`Free to Play`)]
here <- gamedata[is.na(gamedata$`Free to Play`)]
here <- gamedata[is.na(gamedata$`Free to Play`),]
View(moddata)
View(here)
gamedata[is.na(gamedata$`Free to Play`),] <- NULL
NAS <- gamedata[is.na(gamedata$`Free to Play`),]
gamedata <- gamedata[-NAS]
NAS <- gamedata[is.na(gamedata$`Free to Play`),]
gamedata <- gamedata[-NAS,]
